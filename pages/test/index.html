<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>test</title>

    <meta name="editor-canvas-width" content="1920">
    <meta name="editor-canvas-height" content="1080">
    
    <link rel="stylesheet" href="../../static/css/viewer.css">
    
    <style>
        /* Hauteur minimale du canvas */
        .canvas-container {
            min-height: 360px;
        }
        
        /* Style du bouton d'accueil */
        .home-btn {
            display: block;
            width: calc(100% - 4px); /* L√©g√®rement plus petit pour √©viter le d√©bordement */
            padding: 10px;
            background: linear-gradient(135deg, #4a9eff, #667eea);
            border: none;
            color: white;
            border-radius: 6px;
            text-decoration: none;
            text-align: center;
            font-weight: bold;
            font-size: 13px;
            margin: 12px 0 0 0; /* Retirer les marges lat√©rales */
            transition: all 0.3s;
            box-shadow: 0 2px 8px rgba(74, 158, 255, 0.3);
        }
        
        .home-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(74, 158, 255, 0.5);
        }
        
        /* Ajustement de la sidebar header pour un meilleur espacement */
        .sidebar-header {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #4a9eff;
        }

        /* üé® BANNI√àRE DE PAGE SIMPLIFI√âE */
        .page-header {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-bottom: 3px solid #4a9eff;
            margin-bottom: 30px;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        
        .page-header-content {
            display: flex;
            align-items: center;
            gap: 20px;
            padding: 20px 30px;
        }
        
        .page-icon {
            font-size: 42px;
            animation: float 3s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }
        
        .page-main-title {
            font-size: 28px;
            color: #e0e0e0;
            font-weight: 700;
            margin: 0;
            background: linear-gradient(135deg, #4a9eff, #667eea);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        /* üì± RESPONSIVE */
        @media (max-width: 768px) {
            .page-header-content {
                padding: 15px 20px;
            }
            
            .page-icon {
                font-size: 32px;
            }
            
            .page-main-title {
                font-size: 22px;
            }
        }
    </style>
</head>
<body>
    <nav class="sidebar">
        <div class="sidebar-header">
            <h2>üìö test</h2>
            <a href="../../wiki/" class="home-btn">
                üè† Retour √† l'accueil
            </a>
        </div>
        <div class="nav-toggle">
            <button class="nav-btn active" data-tab="links">üîó Liens</button>
            <button class="nav-btn" data-tab="toc">üìã Sommaire</button>
        </div>
        
        <div class="nav-content" id="nav-links">
            <div class="nav-section" id="internal-links-section" style="display:none;">
                <div class="nav-section-title">Liens r√©f√©renc√©s</div>
                <ul class="sidebar-nav" id="internal-links-list"></ul>
            </div>
            
            <div class="nav-section">
                <div class="nav-section-title">Autres pages</div>
                <ul class="sidebar-nav" id="other-pages-list"></ul>
            </div>
        </div>
        
        <div class="nav-content" id="nav-toc" style="display:none;">
            <ul class="toc-list" id="toc-list">
                <li style="color: #666; font-size: 12px; padding: 10px;">Aucun titre trouv√©</li>
            </ul>
        </div>
    </nav>
    
    <main class="content">
        <!-- üé® BANNI√àRE SIMPLIFI√âE -->
        <div class="page-header">
            <div class="page-header-content">
                <div class="page-icon">üó∫Ô∏è</div>
                <h1 class="page-main-title">test</h1>
            </div>
        </div>
        
        <div class="canvas-container">
<div class="component component-text" id="comp-1" data-type="text" style="left:50px;top:50px;width:300px;height:200px;z-index:0;">
<div class="text-content"><p>Lorem ipsum</p></div>
</div>
<div class="component component-shape" id="comp-2" data-type="shape" style="left:1160px;top:40px;width:300px;height:200px;z-index:1;">
<div style="width:100%;height:100%;background:#333333;border-radius:5px;"></div>
</div>
<div class="component component-text" id="comp-3" data-type="text" style="left:1160px;top:60px;width:300px;height:200px;z-index:2;">
<div class="text-content"><p>Titre</p></div>
</div>

        </div>
    </main>
    
    <div class="link-preview" id="link-preview">
        <div class="preview-header" id="preview-title"></div>
        <div class="preview-content" id="preview-content"></div>
        <div class="preview-footer">Cliquez pour ouvrir ‚Üí</div>
    </div>
    
    <script>
        const PAGE_HEADINGS = [];
        const INTERNAL_LINKS = [];
        const CURRENT_SLUG = "test";
        const PAGES_METADATA = {"union-federale-balte-ufb": {"title": "Union F√©d√©rale Balte (UFB)", "slug": "union-federale-balte-ufb", "preview": "Pr√©sentation g√©n√©rale L‚ÄôUnion F√©d√©rale Balte (UFB) est un √âtat f√©d√©ral situ√© en Europe du Nord-Est, structur√© autour du bassin de la mer Baltique. Elle regroupe plusieurs peuples et territoires histor...", "hidden_from_nav": false, "tags": ["pays"]}, "test": {"title": "test", "slug": "test", "preview": "Lorem ipsum Titre", "hidden_from_nav": false, "tags": []}};

        const homeBtn = document.querySelector('.home-btn');
        if (homeBtn) {
            homeBtn.addEventListener('mouseenter', () => {
                homeBtn.style.transform = 'translateY(-2px)';
                homeBtn.style.boxShadow = '0 4px 15px rgba(74, 158, 255, 0.5)';
            });
            homeBtn.addEventListener('mouseleave', () => {
                homeBtn.style.transform = 'translateY(0)';
                homeBtn.style.boxShadow = '0 2px 8px rgba(74, 158, 255, 0.3)';
            });
        }
        
        fetch('../../data/inventory.json')
            .then(res => res.json())
            .then(pages => {
                const visiblePages = pages.filter(p => !p.hidden_from_nav);
                const referencedPages = visiblePages.filter(p => INTERNAL_LINKS.includes(p.slug) && p.slug !== CURRENT_SLUG);
                const otherPages = visiblePages.filter(p => !INTERNAL_LINKS.includes(p.slug) && p.slug !== CURRENT_SLUG);
                
                if (referencedPages.length > 0) {
                    document.getElementById('internal-links-section').style.display = 'block';
                    const internalList = document.getElementById('internal-links-list');
                    referencedPages.forEach(page => {
                        const li = document.createElement('li');
                        const a = document.createElement('a');
                        a.href = `../${page.slug}/`;
                        a.textContent = page.title;
                        li.appendChild(a);
                        internalList.appendChild(li);
                    });
                }
                
                const otherList = document.getElementById('other-pages-list');
                otherPages.forEach(page => {
                    const li = document.createElement('li');
                    const a = document.createElement('a');
                    a.href = `../${page.slug}/`;
                    a.textContent = page.title;
                    li.appendChild(a);
                    otherList.appendChild(li);
                });
            })
            .catch(err => console.error('Erreur chargement navigation:', err));
        
        if (PAGE_HEADINGS.length > 0) {
            const tocList = document.getElementById('toc-list');
            tocList.innerHTML = '';
            PAGE_HEADINGS.forEach(heading => {
                const li = document.createElement('li');
                const a = document.createElement('a');
                a.href = `#${heading.id}`;
                a.textContent = heading.text;
                a.classList.add(`level-${heading.level}`);
                a.addEventListener('click', (e) => {
                    e.preventDefault();
                    const target = document.getElementById(heading.id);
                    if (target) target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                });
                li.appendChild(a);
                tocList.appendChild(li);
            });
        }
        
        document.querySelectorAll('.nav-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                const tab = btn.dataset.tab;
                document.getElementById('nav-links').style.display = tab === 'links' ? 'block' : 'none';
                document.getElementById('nav-toc').style.display = tab === 'toc' ? 'block' : 'none';
            });
        });
        
        const preview = document.getElementById('link-preview');
        let previewTimeout;
        let isOverPreview = false;
        
        function showLinkPreview(linkElement) {
            const href = linkElement.getAttribute('href');
            const match = href.match(/\.\.\/([^\/]+)\//);
            if (!match) return;
            
            const targetSlug = match[1];
            const metadata = PAGES_METADATA[targetSlug];
            
            if (!metadata) {
                console.warn('Pas de m√©tadonn√©es pour', targetSlug);
                return;
            }
            
            document.getElementById('preview-title').textContent = metadata.title;
            document.getElementById('preview-content').textContent = metadata.preview;
            
            const rect = linkElement.getBoundingClientRect();
            preview.style.display = 'block';
            
            let left = rect.right + 15;
            let top = rect.top;
            
            if (left + 400 > window.innerWidth) {
                left = rect.left - 415;
            }
            
            if (top + 250 > window.innerHeight) {
                top = window.innerHeight - 260;
            }
            
            preview.style.left = left + 'px';
            preview.style.top = top + 'px';
        }
        
        document.querySelectorAll('.text-content a[href*="../"]').forEach(link => {
            link.addEventListener('mouseenter', (e) => {
                clearTimeout(previewTimeout);
                previewTimeout = setTimeout(() => {
                    showLinkPreview(e.target);
                }, 300);
            });
            
            link.addEventListener('mouseleave', () => {
                clearTimeout(previewTimeout);
                setTimeout(() => {
                    if (!isOverPreview) {
                        preview.style.display = 'none';
                    }
                }, 200);
            });
        });
        
        preview.addEventListener('mouseenter', () => {
            isOverPreview = true;
        });
        
        preview.addEventListener('mouseleave', () => {
            isOverPreview = false;
            preview.style.display = 'none';
        });
        
        document.querySelectorAll('.component-gallery img').forEach(img => {
            img.addEventListener('click', () => {
                const lightbox = document.createElement('div');
                lightbox.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;cursor:pointer';
                const enlargedImg = document.createElement('img');
                enlargedImg.src = img.src;
                enlargedImg.style.cssText = 'max-width:90%;max-height:90%;object-fit:contain';
                lightbox.appendChild(enlargedImg);
                lightbox.onclick = () => lightbox.remove();
                document.body.appendChild(lightbox);
            });
        });
        
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.style.opacity = '1';
                    entry.target.style.transform = 'translateY(0)';
                }
            });
        }, { threshold: 0.1, rootMargin: '0px 0px -50px 0px' });
        
        document.querySelectorAll('.component').forEach(component => {
            component.style.opacity = '0';
            component.style.transform = 'translateY(20px)';
            component.style.transition = 'opacity 0.5s ease-out, transform 0.5s ease-out';
            observer.observe(component);
        });
        
        console.log('‚úÖ Viewer initialis√©');
        console.log('üìä M√©tadonn√©es:', Object.keys(PAGES_METADATA).length, 'pages');
    </script>
    <script>
        // responsive-layout.js - Syst√®me responsive OPTIMIS√â avec pr√©servation des superpositions

class ResponsiveLayout {
    constructor(options = {}) {
        this.config = {
            editorCanvasWidth: options.editorCanvasWidth || 1920,
            editorCanvasHeight: options.editorCanvasHeight || 1080,
            
            contentMarginLeft: options.contentMarginLeft || 280,
            contentPadding: options.contentPadding || 40,
            
            breakpoints: {
                mobile: 768,
                tablet: 1024,
                desktop: 1440
            },
            
            minSizes: {
                text: { w: 200, h: 80 },
                image: { w: 150, h: 100 },
                gallery: { w: 250, h: 200 },
                video: { w: 300, h: 200 },
                youtube: { w: 300, h: 200 },
                shape: { w: 100, h: 50 },
                table: { w: 250, h: 150 },
                separator: { w: 100, h: 2 }
            },
            
            // ‚úÖ FACTEURS TR√àS AGRESSIFS pour le texte
            heightAdjustFactors: {
                text: 3.0,      // √ó3 pour les textes
                table: 2.5,
                image: 1.0,
                gallery: 1.0,
                video: 0.8,
                youtube: 0.8,
                shape: 0.3,
                separator: 0
            },
            
            componentGap: 15,
            
            ...options
        };
        
        this.originalLayout = null;
        this.currentBreakpoint = this.detectBreakpoint();
    }
    
    init(components) {
        console.log('üîß Initialisation du syst√®me responsive OPTIMIS√â');
        
        this.originalLayout = this.deepClone(components);
        this.currentBreakpoint = this.detectBreakpoint();
        
        const availableWidth = this.getAvailableWidth();
        
        console.log(`üìê Canvas √©diteur: ${this.config.editorCanvasWidth}px`);
        console.log(`üìê Largeur disponible: ${availableWidth}px`);
        console.log(`üìä Breakpoint: ${this.currentBreakpoint}`);
        
        const responsiveComponents = this.applyResponsive(components, availableWidth);
        this.setupResizeListener();
        
        console.log(`‚úÖ Responsive initialis√© - ${responsiveComponents.length} composants`);
        
        return responsiveComponents;
    }
    
    detectBreakpoint() {
        const width = window.innerWidth;
        if (width <= this.config.breakpoints.mobile) return 'mobile';
        if (width <= this.config.breakpoints.tablet) return 'tablet';
        if (width <= this.config.breakpoints.desktop) return 'desktop';
        return 'wide';
    }
    
    getAvailableWidth() {
        const screenWidth = window.innerWidth;
        const breakpoint = this.currentBreakpoint;
        
        if (breakpoint === 'mobile') {
            return screenWidth - (this.config.contentPadding * 2);
        }
        
        return screenWidth - this.config.contentMarginLeft - (this.config.contentPadding * 2);
    }
    
    getScalingRatio(availableWidth) {
        let ratio = availableWidth / this.config.editorCanvasWidth;
        
        const breakpoint = this.currentBreakpoint;
        if (breakpoint === 'mobile') ratio = Math.min(ratio, 0.6);
        else if (breakpoint === 'tablet') ratio = Math.min(ratio, 0.8);
        
        return Math.max(ratio, 0.3);
    }
    
    applyResponsive(components, availableWidth) {
        const ratio = this.getScalingRatio(availableWidth);
        
        console.log(`üìê Ratio de scaling: ${(ratio * 100).toFixed(1)}%`);
        
        let adjusted = this.deepClone(components);
        adjusted.sort((a, b) => a.y - b.y);
        
        // Phase 1 : Scaling avec ajustement hauteur
        adjusted = adjusted.map(comp => this.scaleComponent(comp, ratio, availableWidth));
        
        // Phase 2 : Redistribution S√âLECTIVE (pas toucher aux superpositions)
        adjusted = this.redistributeSelectively(adjusted);
        
        return adjusted;
    }
    
    scaleComponent(component, ratio, availableWidth) {
        const minSize = this.config.minSizes[component.type] || { w: 100, h: 100 };
        const scaled = { ...component };
        
        scaled.x = component.x * ratio;
        scaled.y = component.y * ratio;
        scaled.w = Math.max(minSize.w, component.w * ratio);
        scaled.h = Math.max(minSize.h, component.h * ratio);
        
        const originalScaledW = component.w * ratio;
        let widthWasReduced = false;
        
        // R√©duction de largeur si d√©bordement
        if (scaled.x + scaled.w > availableWidth) {
            const overflow = (scaled.x + scaled.w) - availableWidth;
            
            if (scaled.x > 20) {
                const shift = Math.min(overflow, scaled.x - 10);
                scaled.x -= shift;
            }
            
            if (scaled.x + scaled.w > availableWidth) {
                scaled.w = Math.max(minSize.w, availableWidth - scaled.x - 10);
                widthWasReduced = true;
            }
        }
        
        const widthCompressionRatio = scaled.w / originalScaledW;
        
        // ‚úÖ AJUSTEMENT HAUTEUR TR√àS AGRESSIF pour le texte
        if (widthCompressionRatio < 0.98 || widthWasReduced) {
            const heightFactor = this.config.heightAdjustFactors[component.type] || 1.5;
            
            // Formule TR√àS agressive
            const compressionFactor = 1 / widthCompressionRatio;
            const heightMultiplier = 1 + ((compressionFactor - 1) * heightFactor);
            
            const baseHeight = component.h * ratio;
            const newHeight = baseHeight * heightMultiplier;
            const heightDelta = newHeight - baseHeight;
            
            scaled.h = newHeight;
            scaled._heightIncreased = heightDelta;
            
            console.log(`üìè ${component.id} (${component.type}): ${(widthCompressionRatio * 100).toFixed(0)}% ‚Üí +${heightDelta.toFixed(0)}px`);
        } else {
            scaled._heightIncreased = 0;
        }
        
        scaled._originalY = component.y * ratio;
        scaled._originalBottom = (component.y + component.h) * ratio;
        
        return scaled;
    }
    
    /**
     * ‚úÖ Redistribution S√âLECTIVE : pr√©serve les superpositions
     */
    redistributeSelectively(components) {
        const adjusted = [];
        
        for (let i = 0; i < components.length; i++) {
            let current = { ...components[i] };
            let needsRepositioning = false;
            
            // V√©rifier les collisions avec les composants d√©j√† plac√©s
            for (let j = 0; j < adjusted.length; j++) {
                const existing = adjusted[j];
                
                if (this.doOverlap(current, existing)) {
                    // ‚úÖ CLEF : V√©rifier si c'est une superposition INTENTIONNELLE
                    if (this.isIntentionalOverlap(current, existing)) {
                        console.log(`‚ú® Superposition pr√©serv√©e: ${current.id} ‚Üî ${existing.id}`);
                        // NE PAS d√©caler
                    } else {
                        // Collision accidentelle ‚Üí d√©caler
                        const newY = existing.y + existing.h + this.config.componentGap;
                        console.log(`üîΩ ${current.id} d√©cal√© de ${current.y.toFixed(0)} ‚Üí ${newY.toFixed(0)}px`);
                        current.y = newY;
                        needsRepositioning = true;
                    }
                }
            }
            
            delete current._originalY;
            delete current._originalBottom;
            
            adjusted.push(current);
        }
        
        return adjusted;
    }
    
    doOverlap(comp1, comp2) {
        const tolerance = 3;
        return !(
            comp1.x + comp1.w < comp2.x + tolerance ||
            comp2.x + comp2.w < comp1.x + tolerance ||
            comp1.y + comp1.h < comp2.y + tolerance ||
            comp2.y + comp2.h < comp1.y + tolerance
        );
    }
    
    /**
     * ‚úÖ D√©tection AM√âLIOR√âE des superpositions intentionnelles
     */
    isIntentionalOverlap(comp1, comp2) {
        if (!this.doOverlap(comp1, comp2)) return false;
        
        const overlapX = Math.max(0, Math.min(comp1.x + comp1.w, comp2.x + comp2.w) - Math.max(comp1.x, comp2.x));
        const overlapY = Math.max(0, Math.min(comp1.y + comp1.h, comp2.y + comp2.h) - Math.max(comp1.y, comp2.y));
        const overlapArea = overlapX * overlapY;
        
        const area1 = comp1.w * comp1.h;
        const area2 = comp2.w * comp2.h;
        const minArea = Math.min(area1, area2);
        
        // ‚úÖ Si > 15% de surface commune = intentionnel
        return overlapArea > minArea * 0.15;
    }
    
    applyToDOM(components) {
        components.forEach(comp => {
            const element = document.getElementById(comp.id);
            if (!element) {
                console.warn(`‚ö†Ô∏è ${comp.id} introuvable`);
                return;
            }
            
            element.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
            element.style.left = `${comp.x}px`;
            element.style.top = `${comp.y}px`;
            element.style.width = `${comp.w}px`;
            element.style.height = `${comp.h}px`;
            
            if (comp.type === 'text') {
                this.adjustTextSize(element, comp);
            }
        });
        
        this.adjustCanvasHeight(components);
    }
    
    adjustTextSize(element, component) {
        const textContent = element.querySelector('.text-content');
        if (!textContent) return;
        
        const ratio = this.getScalingRatio(this.getAvailableWidth());
        const breakpoint = this.currentBreakpoint;
        
        let baseFontSize = 15;
        if (breakpoint === 'mobile') baseFontSize = 13;
        else if (breakpoint === 'tablet') baseFontSize = 14;
        
        const fontSize = Math.max(11, baseFontSize * Math.min(ratio, 1));
        
        textContent.style.fontSize = `${fontSize}px`;
        textContent.style.lineHeight = '1.6';
        textContent.style.overflowY = 'auto';
        textContent.style.padding = '12px';
    }
    
    adjustCanvasHeight(components) {
        const canvas = document.querySelector('.canvas-container');
        if (!canvas) return;
        
        let maxBottom = 0;
        components.forEach(comp => {
            const bottom = comp.y + comp.h;
            if (bottom > maxBottom) maxBottom = bottom;
        });
        
        canvas.style.minHeight = `${maxBottom + 100}px`;
    }
    
    setupResizeListener() {
        let resizeTimer;
        
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            
            resizeTimer = setTimeout(() => {
                const newBreakpoint = this.detectBreakpoint();
                
                if (newBreakpoint !== this.currentBreakpoint) {
                    console.log(`üîÑ ${this.currentBreakpoint} ‚Üí ${newBreakpoint}`);
                    this.currentBreakpoint = newBreakpoint;
                    
                    if (this.originalLayout) {
                        const availableWidth = this.getAvailableWidth();
                        const responsive = this.applyResponsive(this.originalLayout, availableWidth);
                        this.applyToDOM(responsive);
                    }
                }
            }, 250);
        });
    }
    
    deepClone(obj) {
        return JSON.parse(JSON.stringify(obj));
    }
    
    getDebugInfo() {
        const availableWidth = this.getAvailableWidth();
        const ratio = this.getScalingRatio(availableWidth);
        
        return {
            breakpoint: this.currentBreakpoint,
            ratio: ratio,
            editorCanvasWidth: this.config.editorCanvasWidth,
            availableWidth: availableWidth,
            screenWidth: window.innerWidth,
            componentsCount: this.originalLayout?.length || 0
        };
    }
    
    showDebugOverlay() {
        document.getElementById('responsive-debug-overlay')?.remove();
        
        const overlay = document.createElement('div');
        overlay.id = 'responsive-debug-overlay';
        overlay.style.cssText = `
            position: fixed;
            bottom: 20px;
            left: 300px;
            background: rgba(0, 0, 0, 0.95);
            color: #0f0;
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            z-index: 100000;
            max-width: 400px;
            box-shadow: 0 4px 15px rgba(0, 255, 0, 0.5);
            border: 2px solid #0f0;
        `;
        
        const info = this.getDebugInfo();
        const components = document.querySelectorAll('.component');
        let heightIncreasedCount = 0;
        let totalHeightIncrease = 0;
        let overflowCount = 0;
        
        components.forEach(el => {
            const h = parseFloat(el.style.height);
            const id = el.id;
            const comp = this.originalLayout?.find(c => c.id === id);
            
            if (comp) {
                const originalH = comp.h * info.ratio;
                const delta = h - originalH;
                if (delta > 5) {
                    heightIncreasedCount++;
                    totalHeightIncrease += delta;
                }
            }
            
            // D√©tecter overflow
            if (el.dataset.type === 'text') {
                const textContent = el.querySelector('.text-content');
                if (textContent && textContent.scrollHeight > textContent.clientHeight + 5) {
                    overflowCount++;
                }
            }
        });
        
        overlay.innerHTML = `
            <strong style="color: #0ff; font-size: 14px;">üìä RESPONSIVE DEBUG</strong><br>
            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #0f0;">
                Breakpoint: <span style="color: #ff0;">${info.breakpoint}</span><br>
                Ratio: <span style="color: #ff0;">${(info.ratio * 100).toFixed(0)}%</span><br>
                Canvas √©diteur: <span style="color: #ff0;">${info.editorCanvasWidth}px</span><br>
                Largeur dispo: <span style="color: #ff0;">${info.availableWidth}px</span><br>
            </div>
            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #0f0;">
                Composants: <span style="color: #ff0;">${info.componentsCount}</span><br>
                Hauteurs augment√©es: <span style="color: ${heightIncreasedCount > 0 ? '#0f0' : '#666'}">${heightIncreasedCount}</span><br>
                Total ajout√©: <span style="color: #0f0; font-weight: bold;">+${totalHeightIncrease.toFixed(0)}px</span><br>
                <strong style="color: ${overflowCount > 0 ? '#f00' : '#0f0'}">Textes en overflow: ${overflowCount}</strong><br>
            </div>
            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #0f0;">
                <button onclick="window.responsiveLayout.hideDebugOverlay()" style="
                    background: #f00;
                    color: white;
                    border: none;
                    padding: 8px 15px;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 12px;
                    font-weight: bold;
                ">‚úñ Fermer</button>
            </div>
        `;
        
        document.body.appendChild(overlay);
    }
    
    hideDebugOverlay() {
        document.getElementById('responsive-debug-overlay')?.remove();
    }
    
    reset() {
        if (!this.originalLayout) return;
        this.applyToDOM(this.originalLayout);
        console.log('üîÑ Layout r√©initialis√©');
    }
}

// INITIALISATION AUTOMATIQUE
if (typeof window !== 'undefined') {
    document.addEventListener('DOMContentLoaded', () => {
        setTimeout(() => {
            const components = Array.from(document.querySelectorAll('.component')).map(el => {
                const typeClass = Array.from(el.classList).find(cls => cls.startsWith('component-'));
                const type = typeClass ? typeClass.replace('component-', '') : 'unknown';
                
                return {
                    id: el.id,
                    type: type,
                    x: parseFloat(el.style.left) || 0,
                    y: parseFloat(el.style.top) || 0,
                    w: parseFloat(el.style.width) || 300,
                    h: parseFloat(el.style.height) || 200,
                    z: parseInt(el.style.zIndex) || 0
                };
            });
            
            if (components.length > 0) {
                const editorWidth = parseInt(document.querySelector('meta[name="editor-canvas-width"]')?.content) || 1920;
                const editorHeight = parseInt(document.querySelector('meta[name="editor-canvas-height"]')?.content) || 1080;
                
                console.log(`üì¶ ${components.length} composants | Canvas: ${editorWidth}√ó${editorHeight}px`);
                
                window.responsiveLayout = new ResponsiveLayout({
                    editorCanvasWidth: editorWidth,
                    editorCanvasHeight: editorHeight
                });
                
                const responsive = window.responsiveLayout.init(components);
                window.responsiveLayout.applyToDOM(responsive);
                
                console.log('‚úÖ Responsive OPTIMIS√â activ√©');
                console.log('üí° Commandes: ResponsiveDebug.showAll() | ResponsiveDebug.report()');
            }
        }, 200);
    });
}

if (typeof module !== 'undefined' && module.exports) {
    module.exports = ResponsiveLayout;
}
        // utils/debug.js - Utilitaires de debug pour le syst√®me responsive

/**
 * Classe d'utilitaires de debug
 */
class ResponsiveDebugUtils {
    constructor() {
        this.overlaysActive = new Set();
        this.setupGlobalCommands();
    }
    
    /**
     * Setup des commandes globales
     */
    setupGlobalCommands() {
        if (typeof window !== 'undefined') {
            window.ResponsiveDebug = {
                // Afficher les contours
                showBorders: () => this.showComponentBorders(),
                hideBorders: () => this.hideComponentBorders(),
                
                // Afficher les coordonn√©es
                showCoords: () => this.showComponentCoords(),
                hideCoords: () => this.hideComponentCoords(),
                
                // Afficher les infos de texte
                showTextInfo: () => this.showTextInfo(),
                hideTextInfo: () => this.hideTextInfo(),
                
                // Tout afficher
                showAll: () => {
                    this.showComponentBorders();
                    this.showComponentCoords();
                    this.showTextInfo();
                },
                
                // Tout cacher
                hideAll: () => {
                    this.hideComponentBorders();
                    this.hideComponentCoords();
                    this.hideTextInfo();
                },
                
                // Overlay principal
                showOverlay: () => window.responsiveLayout?.showDebugOverlay(),
                hideOverlay: () => window.responsiveLayout?.hideDebugOverlay(),
                
                // Rapport complet
                report: () => this.generateReport(),
                
                // V√©rifier la taille du canvas
                checkCanvasSize: () => this.checkCanvasSize()
            };
            
            console.log('üõ†Ô∏è Debug utils charg√©s. Commandes disponibles:');
            console.log('  ResponsiveDebug.showBorders()');
            console.log('  ResponsiveDebug.showCoords()');
            console.log('  ResponsiveDebug.showTextInfo()');
            console.log('  ResponsiveDebug.showAll()');
            console.log('  ResponsiveDebug.hideAll()');
            console.log('  ResponsiveDebug.report()');
            console.log('  ResponsiveDebug.checkCanvasSize()');
        }
    }
    
    /**
     * ‚úÖ V√©rifier la taille du canvas (NOUVEAU)
     */
    checkCanvasSize() {
        const meta = {
            width: document.querySelector('meta[name="editor-canvas-width"]')?.content,
            height: document.querySelector('meta[name="editor-canvas-height"]')?.content
        };
        
        const canvas = document.querySelector('.canvas-container');
        const actual = canvas ? {
            width: canvas.offsetWidth,
            height: canvas.offsetHeight
        } : null;
        
        console.group('üìê V√©rification taille canvas');
        console.log('Meta tags:', meta);
        console.log('Canvas actuel:', actual);
        
        if (meta.width && parseInt(meta.width) < 1900) {
            console.warn('‚ö†Ô∏è PROBL√àME: Canvas √©diteur trop petit!');
            console.warn(`   Valeur actuelle: ${meta.width}px`);
            console.warn(`   Valeur attendue: ~1920px`);
            console.warn('   ‚Üí La taille du canvas n\'a pas √©t√© sauvegard√©e correctement');
        }
        
        console.groupEnd();
        
        return { meta, actual };
    }
    
    /**
     * Afficher les contours des composants
     */
    showComponentBorders() {
        if (this.overlaysActive.has('borders')) return;
        
        const style = document.createElement('style');
        style.id = 'debug-borders';
        style.textContent = `
            .component {
                outline: 2px solid rgba(255, 0, 0, 0.5) !important;
                outline-offset: -2px;
            }
            
            .component::before {
                content: attr(id) " (" attr(data-type) ")";
                position: absolute;
                top: 0;
                left: 0;
                background: rgba(255, 0, 0, 0.8);
                color: white;
                padding: 2px 6px;
                font-size: 10px;
                font-family: monospace;
                z-index: 100000;
                pointer-events: none;
            }
            
            .component-text {
                outline-color: rgba(0, 255, 0, 0.5) !important;
            }
            
            .component-text::before {
                background: rgba(0, 255, 0, 0.8) !important;
            }
        `;
        
        document.head.appendChild(style);
        this.overlaysActive.add('borders');
        
        console.log('‚úÖ Contours affich√©s (rouge = g√©n√©ral, vert = texte)');
    }
    
    hideComponentBorders() {
        document.getElementById('debug-borders')?.remove();
        this.overlaysActive.delete('borders');
        console.log('‚ùå Contours masqu√©s');
    }
    
    /**
     * Afficher les coordonn√©es des composants
     */
    showComponentCoords() {
        if (this.overlaysActive.has('coords')) return;
        
        document.querySelectorAll('.component').forEach(el => {
            const coords = document.createElement('div');
            coords.className = 'debug-coords';
            coords.style.cssText = `
                position: absolute;
                bottom: 0;
                right: 0;
                background: rgba(0, 0, 255, 0.8);
                color: white;
                padding: 4px 8px;
                font-size: 10px;
                font-family: monospace;
                z-index: 100000;
                pointer-events: none;
                border-radius: 3px 0 0 0;
            `;
            
            const x = parseFloat(el.style.left) || 0;
            const y = parseFloat(el.style.top) || 0;
            const w = parseFloat(el.style.width) || 0;
            const h = parseFloat(el.style.height) || 0;
            
            coords.textContent = `X:${x.toFixed(0)} Y:${y.toFixed(0)} W:${w.toFixed(0)} H:${h.toFixed(0)}`;
            el.appendChild(coords);
        });
        
        this.overlaysActive.add('coords');
        console.log('‚úÖ Coordonn√©es affich√©es');
    }
    
    hideComponentCoords() {
        document.querySelectorAll('.debug-coords').forEach(el => el.remove());
        this.overlaysActive.delete('coords');
        console.log('‚ùå Coordonn√©es masqu√©es');
    }
    
    /**
     * Afficher les infos de texte
     */
    showTextInfo() {
        if (this.overlaysActive.has('textinfo')) return;
        
        document.querySelectorAll('.component-text').forEach(el => {
            const textContent = el.querySelector('.text-content');
            if (!textContent) return;
            
            const info = document.createElement('div');
            info.className = 'debug-textinfo';
            info.style.cssText = `
                position: absolute;
                top: 0;
                right: 0;
                background: rgba(255, 165, 0, 0.9);
                color: white;
                padding: 4px 8px;
                font-size: 10px;
                font-family: monospace;
                z-index: 100001;
                pointer-events: none;
                max-width: 200px;
                border-radius: 0 0 0 3px;
            `;
            
            const fontSize = window.getComputedStyle(textContent).fontSize;
            const lineHeight = window.getComputedStyle(textContent).lineHeight;
            const textLength = textContent.textContent.length;
            const scrollHeight = textContent.scrollHeight;
            const clientHeight = textContent.clientHeight;
            const overflow = scrollHeight > clientHeight;
            
            info.innerHTML = `
                Font: ${fontSize}<br>
                Line: ${lineHeight}<br>
                Chars: ${textLength}<br>
                ${overflow ? '<strong style="color:#ff0;">‚ö†Ô∏è OVERFLOW!</strong>' : '‚úì OK'}
            `;
            
            el.appendChild(info);
        });
        
        this.overlaysActive.add('textinfo');
        console.log('‚úÖ Infos texte affich√©es');
    }
    
    hideTextInfo() {
        document.querySelectorAll('.debug-textinfo').forEach(el => el.remove());
        this.overlaysActive.delete('textinfo');
        console.log('‚ùå Infos texte masqu√©es');
    }
    
    /**
     * G√©n√©rer un rapport complet
     */
    generateReport() {
        const components = Array.from(document.querySelectorAll('.component'));
        const info = window.responsiveLayout?.getDebugInfo();
        
        console.group('üìä RAPPORT RESPONSIVE COMPLET');
        
        // Infos g√©n√©rales
        console.log('üìê Configuration:');
        console.table(info);
        
        // V√©rification canvas
        const canvasCheck = this.checkCanvasSize();
        
        // Infos par composant
        console.log('\nüì¶ Composants:');
        const componentData = components.map(el => {
            const type = el.dataset.type;
            const x = parseFloat(el.style.left) || 0;
            const y = parseFloat(el.style.top) || 0;
            const w = parseFloat(el.style.width) || 0;
            const h = parseFloat(el.style.height) || 0;
            
            // Calculer si le texte overflow
            let overflow = false;
            if (type === 'text') {
                const textContent = el.querySelector('.text-content');
                if (textContent) {
                    overflow = textContent.scrollHeight > textContent.clientHeight;
                }
            }
            
            return {
                id: el.id,
                type,
                x: x.toFixed(0),
                y: y.toFixed(0),
                w: w.toFixed(0),
                h: h.toFixed(0),
                overflow: overflow ? '‚ö†Ô∏è' : '‚úì'
            };
        });
        
        console.table(componentData);
        
        // Probl√®mes d√©tect√©s
        const problems = [];
        
        if (canvasCheck.meta.width && parseInt(canvasCheck.meta.width) < 1900) {
            problems.push('Canvas √©diteur trop petit (< 1900px)');
        }
        
        const overflowCount = componentData.filter(c => c.overflow === '‚ö†Ô∏è').length;
        if (overflowCount > 0) {
            problems.push(`${overflowCount} composant(s) texte en overflow`);
        }
        
        if (info && info.ratio > 1.1) {
            problems.push('Ratio > 110% : √©cran plus grand que l\'√©diteur (pas normal)');
        }
        
        if (problems.length > 0) {
            console.warn('\n‚ö†Ô∏è PROBL√àMES D√âTECT√âS:');
            problems.forEach((p, i) => console.warn(`  ${i + 1}. ${p}`));
        } else {
            console.log('\n‚úÖ Aucun probl√®me d√©tect√©');
        }
        
        console.groupEnd();
        
        return {
            info,
            components: componentData,
            problems
        };
    }
}

// Initialisation automatique
if (typeof window !== 'undefined') {
    document.addEventListener('DOMContentLoaded', () => {
        window.debugUtils = new ResponsiveDebugUtils();
    });
}

// Export
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ResponsiveDebugUtils;
}
    </script>
    
    

    <style>
        .hidden-warning-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.3s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .hidden-warning-modal {
            background: linear-gradient(135deg, #1a1a2e 0%, #2d2d44 100%);
            border: 2px solid #ff6b6b;
            border-radius: 20px;
            padding: 50px 40px;
            max-width: 600px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(255, 107, 107, 0.3);
            animation: slideUp 0.4s ease-out;
        }
        
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .warning-icon {
            font-size: 80px;
            margin-bottom: 25px;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .hidden-warning-modal h2 {
            color: #ff6b6b;
            font-size: 32px;
            margin-bottom: 25px;
            font-weight: 700;
        }
        
        .warning-text {
            color: #e0e0e0;
            font-size: 18px;
            line-height: 1.6;
            margin-bottom: 20px;
        }
        
        .warning-text strong {
            color: #ff6b6b;
            font-weight: 700;
        }
        
        .warning-subtext {
            color: #999;
            font-size: 15px;
            line-height: 1.6;
            margin-bottom: 35px;
            padding: 20px;
            background: rgba(255, 107, 107, 0.1);
            border-radius: 10px;
            border-left: 4px solid #ff6b6b;
        }
        
        .warning-subtext strong {
            color: #4a9eff;
        }
        
        .warning-actions {
            margin-top: 30px;
        }
        
        .btn-accept {
            background: linear-gradient(135deg, #4a9eff, #667eea);
            color: white;
            border: none;
            padding: 15px 50px;
            border-radius: 50px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(74, 158, 255, 0.3);
        }
        
        .btn-accept:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(74, 158, 255, 0.5);
        }
        
        .btn-accept:active {
            transform: translateY(-1px);
        }
        
        @media (max-width: 768px) {
            .hidden-warning-modal {
                margin: 20px;
                padding: 40px 30px;
            }
            
            .warning-icon {
                font-size: 60px;
            }
            
            .hidden-warning-modal h2 {
                font-size: 24px;
            }
            
            .warning-text {
                font-size: 16px;
            }
        }
    </style>
    
    <script>
        // Gestion de la pop-in d'avertissement
        const warningOverlay = document.getElementById('hidden-page-warning');
        const acceptBtn = document.getElementById('accept-warning');
        
        if (warningOverlay && acceptBtn) {
            // Emp√™cher le scroll en arri√®re-plan
            document.body.style.overflow = 'hidden';
            
            acceptBtn.addEventListener('click', () => {
                warningOverlay.style.animation = 'fadeOut 0.3s ease-out';
                
                setTimeout(() => {
                    warningOverlay.remove();
                    document.body.style.overflow = '';
                }, 300);
            });
            
            // Emp√™cher la fermeture en cliquant √† c√¥t√©
            warningOverlay.addEventListener('click', (e) => {
                if (e.target === warningOverlay) {
                    // Animation de secousse pour indiquer qu'on doit cliquer sur le bouton
                    const modal = warningOverlay.querySelector('.hidden-warning-modal');
                    modal.style.animation = 'shake 0.5s ease-in-out';
                    setTimeout(() => {
                        modal.style.animation = '';
                    }, 500);
                }
            });
        }
    </script>
    
    <style>
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }
    </style>
</body>
</html>